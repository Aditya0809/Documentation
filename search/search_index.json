{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Homepage","text":"<p>PetIGA extends the PETSc toolkit by adding NURBS\u2010based isogeometric discretisation and automated form integration.  With it you can build 2\u2011D and 3\u2011D solvers\u2014linear or nonlinear, steady or transient\u2014without writing domain\u2011decomposition, MPI halo\u2011exchange, or low\u2011level assembly code.  The major aim while using PetIGA is to code the residual (or right\u2011hand side in explicit cases) and, if needed, the Jacobian at each Gauss point; PetIGA and PETSc handles everything else.</p>"},{"location":"#advantages-of-explicit-time-stepping","title":"Advantages of explicit time stepping","text":"Benefit Comment Low memory footprint No global matrix inversion; ideal when the number of degrees of freedom (DOFs) is very large. No Jacobian required Saves coding effort and sidesteps numerical differentiation costs. Embarrassingly parallel Each time step is mostly local, giving excellent scalability. Simple to implement Update rule is a vector operation; easy to understand. <p>Caveat: stability is dictated by a CFL\u2011type time\u2010step limit.</p>"},{"location":"#petigas-capabilities","title":"PetIGA\u2019s capabilities","text":"<ul> <li>NURBS / B\u2011spline basis for exact CAD geometry and high\u2011order,\u00a0\\(C^{p-1}\\) continuity.</li> <li>Unified API for linear, nonlinear, and time\u2011dependent PDEs.</li> <li>Strong scaling demonstrated to 2048 CPU cores on problems in solid &amp; fluid mechanics.</li> <li>Automatic numerical differentiation available when an analytic Jacobian is tedious to formulate.</li> <li>Open\u2011source, MIT licence \u2013 easy to comprehend, extend, and reuse alongside PETSc\u2019s solvers and preconditioners.</li> </ul>"},{"location":"#overview","title":"Overview","text":"<ol> <li>Installation guide - install and compile the modified PetIGA and Petsc</li> <li>Quick\u2011start tutorials \u2013 running your first 2\u2011D heat conduction example.  </li> <li>Worked examples in fourth-order Cahn Hilliard equation.  </li> <li>Scaling tips \u2013 how to push your model to hundreds of millions of DOFs (check References).  </li> <li>Reference pages \u2013 installation flags, command\u2011line options, and helper scripts.</li> </ol> <p>This guide will get you productive with explicit PetIGA and PETSc.</p>"},{"location":"#references","title":"References","text":"<ol> <li> <p>Paspunurwar, A., Moure, A. &amp; Gomez, H. Dynamic cluster field modeling of collective chemotaxis. Sci Rep 14, 25162 (2024). https://doi.org/10.1038/s41598-024-75653-1</p> </li> <li> <p>Paspunurwar, A.S., Gomez, H. Decoding complex transport patterns in flow-induced autologous chemotaxis of multicellular systems. Biomech Model Mechanobiol 24, 197\u2013212 (2025). https://doi.org/10.1007/s10237-024-01905-8</p> </li> </ol>"},{"location":"installation/","title":"Software Installation","text":"<p>Here is a detailed guide for installing PETSc, modified PetIGA, and IgaKit on the Bridges2 cluster.</p>"},{"location":"installation/#necessary-modules","title":"Necessary modules","text":"<ol> <li>mkl</li> <li>intelmpi/2021.3.0-intel2021.3.0</li> <li>anaconda (for IGAKIT) </li> </ol>"},{"location":"installation/#petsc","title":"PETSc","text":"<ol> <li> <p>Clone the PETSc repository  : Download PETSc</p> </li> <li> <p>Copy modified files from this repository    This project uses a modified version of PETSc to support explicit time stepping with a lumped mass matrix in the IGA context.</p> <p>To enable this, two core PETSc source files have been updated:</p> <ul> <li><code>euler.c</code> : located in <code>src/ts/impls/explicit/</code></li> <li><code>tsimpl.h</code>: located in <code>include/petsc/private/</code></li> </ul> <p>You can download the modified versions from this repository: changes_petsc</p> <p>\ud83d\udd27 Summary of Changes</p> <p>\u2705 <code>tsimpl.h</code> (structure update)</p> <p>A new vector field for the lumped mass matrix has been added to the internal <code>TS</code> structure:</p> <p><pre><code>/*----------------------- Lumped Mass Matrix -----------------------------------*/\nVec vec_lump;\n</code></pre> This line is inserted inside the <code>_p_TS</code> structure to store the vector of lumped mass coefficients. </p> <p>\u2705 <code>euler.c</code> (RHS update in TSStep_Euler())</p> <p>The right-hand side (RHS) vector is now divided by the lumped mass vector (<code>vec_lump</code>) before updating the solution, as shown below:</p> <pre><code>    TS_Euler       *euler = (TS_Euler*)ts-&gt;data;\n    Vec            solution = ts-&gt;vec_sol, update = euler-&gt;update;\n    Vec            lmc = ts-&gt;vec_lump, update2 = euler-&gt;update;\n    PetscBool      stageok, accept = PETSC_TRUE;\n    PetscReal      next_time_step = ts-&gt;time_step;\n    PetscErrorCode ierr;\n\n    PetscFunctionBegin;\n    ierr = TSPreStage(ts, ts-&gt;ptime);CHKERRQ(ierr);\n    ierr = TSComputeRHSFunction(ts, ts-&gt;ptime, solution, update);CHKERRQ(ierr);\n    ierr = VecPointwiseDivide(update2, update, lmc);\n    ierr = VecAXPY(solution, ts-&gt;time_step, update2);CHKERRQ(ierr);\n    ierr = TSPostStage(ts, ts-&gt;ptime, 0, &amp;solution);CHKERRQ(ierr);\n    ierr = TSAdaptCheckStage(ts-&gt;adapt, ts, ts-&gt;ptime, solution, &amp;stageok);CHKERRQ(ierr);\n    if (!stageok) {\n    ts-&gt;reason = TS_DIVERGED_STEP_REJECTED;\n    PetscFunctionReturn(0);\n    }\n    ierr = TSFunctionDomainError(ts, ts-&gt;ptime + ts-&gt;time_step, update, &amp;stageok);CHKERRQ(ierr);\n    if (!stageok) {\n    ts-&gt;reason = TS_DIVERGED_STEP_REJECTED;\n    PetscFunctionReturn(0);\n    }\n    ierr = TSAdaptChoose(ts-&gt;adapt, ts, ts-&gt;time_step, NULL, &amp;next_time_step, &amp;accept);CHKERRQ(ierr);\n    if (!accept) {\n    ts-&gt;reason = TS_DIVERGED_STEP_REJECTED;\n    PetscFunctionReturn(0);\n    }\n    ierr = VecCopy(solution, update);CHKERRQ(ierr);\n    ierr = VecCopy(solution, ts-&gt;vec_sol);CHKERRQ(ierr);\n\n    ts-&gt;ptime += ts-&gt;time_step;\n    ts-&gt;time_step = next_time_step;\n    PetscFunctionReturn(0);\n</code></pre> <p>These changes enable the use of lumped mass matrix-based explicit integration schemes, which are particularly useful when using PetIGA for transient simulations.</p> </li> <li> <p>Replace PETSc source files </p> </li> <li>Change <code>tsimpl.h</code> file located at:      <pre><code>/path-to-petsc/include/petsc/private/tsimpl.h\n</code></pre></li> <li> <p>Overwite the original euler.c found at:      <pre><code>/path-to-petsc/src/ts/impls/explicit/euler.c\n</code></pre></p> </li> <li> <p>Configure and compile PETSc    Follow the official guide: PETSc Installation    Example configuration:    <pre><code>OPTFLAGS=\"-Ofast -march=native -mavx2 -mfma -fno-finite-math-only\"\n./configure --with-debugging=no \\\n    COPTFLAGS=\"$OPTFLAGS\" \\\n    CXXOPTFLAGS=\"$OPTFLAGS\" \\\n    FOPTFLAGS=\"$OPTFLAGS\" \\\n    --with-blaslapack-dir=$MKLROOT \\\n    --with-scalapack-lib=\"-L$MKLROOT/lib/intel64 -lmkl_scalapack_lp64 -lmkl_blacs_intelmpi_lp64\" \\\n    --with-scalapack-include=$MKLROOT/include\nmake all\n</code></pre></p> </li> <li> <p>Set environment variables     After successful configuration, define the following:     <pre><code>    export PETSC_DIR=/path/to/petsc\n    export PETSC_ARCH=your-architecture-name\n</code></pre></p> </li> </ol>"},{"location":"installation/#petiga","title":"PetIGA","text":"<p>This project uses a modified version of PetIGA, originally developed by L. Dalcin et al. You can download our version here: Download mod_PetIGA.zip </p> <ol> <li>Navigate to the <code>mod_PetIGA</code> folder you've downloaded. </li> <li>Run: <code>make all make test</code>  for compilation and testing</li> <li>Set the following environment variables:      <pre><code>    export PETIGA_DIR=/path/to/mod_PetIGA \n    export PETIGA_ARCH=your-arch \n</code></pre></li> </ol>"},{"location":"installation/#why-we-modified-petiga","title":"Why we modified PetIGA","text":"<p>The original PetIGA implementation performs explicit time stepping as: \\[ U^{n+1} = U^n + \\Delta t \\cdot \\mathcal{R}(U^n) \\]  However, this ignores the presence of the mass matrix, which should appear in the weak form of time discretization.  The proper discretized formulation is: \\[ M \\cdot U^{n+1} = M \\cdot U^n + \\Delta t \\cdot \\mathcal{R}(U^n) \\]  To avoid the cost of inverting \\( M \\), we apply the lumped mass matrix technique, where: </p> \\[     \\mathcal{M}_{AB}=\\begin{cases}           \\sum_{b=1}^{n_b} {M}_{Ab} \\: &amp; \\text{if} \\; A=B, \\\\           0 \\: &amp; \\text{if} \\; A\\neq B. \\       \\end{cases} \\] <p>This converts the system into a diagonal form, allowing for efficient inversion: \\[ U^{n+1} = U^n + \\Delta t \\cdot \\mathcal{M}^{-1} \\mathcal{R}(U^n) \\]  This modification improves performance in explicit schemes while maintaining physical correctness.</p>"},{"location":"installation/#extra-note-on-the-explicit-rhs-helper","title":"Extra note on the explicit RHS helper","text":"<p>In the stock PetIGA API you call <code>IGACreateTS()</code> (implicit, Jacobian\u2011based) or <code>IGACreateTS2()</code> (matrix\u2011free). For purely explicit schemes we added a convenience wrapper:</p> <pre><code>    /* Purpose: create a PETSc TS object, attach the IGA,\n    *          and wire the **right\u2011hand side only** callback\n    *          required for explicit time steppers (TSEULER, TSRK, etc.) */\n    PetscErrorCode IGACreateTS3(IGA iga, TS *ts)\n    {\n    MPI_Comm       comm;\n    Vec            U;\n    Vec            F;\n    Mat            J;\n    PetscErrorCode ierr;\n\n    PetscFunctionBegin;\n    PetscValidHeaderSpecific(iga,IGA_CLASSID,1);\n    PetscValidPointer(ts,2);\n\n    ierr = IGAGetComm(iga,&amp;comm);CHKERRQ(ierr);\n    ierr = TSCreate(comm,ts);CHKERRQ(ierr);\n    ierr = PetscObjectCompose((PetscObject)*ts,\"IGA\",(PetscObject)iga);CHKERRQ(ierr);\n    ierr = IGASetOptionsHandlerTS(*ts);CHKERRQ(ierr);\n\n    ierr = IGACreateVec(iga,&amp;U);CHKERRQ(ierr);\n    ierr = TSSetSolution(*ts,U);CHKERRQ(ierr);\n    ierr = VecDestroy(&amp;U);CHKERRQ(ierr);\n\n    ierr = IGACreateVec(iga,&amp;F);CHKERRQ(ierr);\n    ierr = TSSetRHSFunction(*ts,F,IGATSFormRHSFunction,iga);CHKERRQ(ierr);\n    ierr = VecDestroy(&amp;F);CHKERRQ(ierr);\n\n    PetscFunctionReturn(0);\n    }\n</code></pre> <p>Key steps inside <code>IGACreateTS3()</code> :</p> Step What it does 1 <code>TSCreate</code> and attach the IGA object via <code>PetscObjectCompose</code>. 2 Allocate a global vector U and register it with <code>TSSetSolution</code>. 3 Allocate a work vector F and register only the RHS via <code>TSSetRHSFunction</code>; no Jacobian is set. <p>The actual residual assembly is delegated to <code>IGATSFormRHSFunction()</code>, so later you simply call:</p> <pre><code>    TSSetType(ts, TSEULER);   /* or TSRK, etc. */\n    TSSolve(ts, U);           /* PETSc advances with explicit lumped\u2011mass update */\n</code></pre>"},{"location":"installation/#igakit-for-visualization","title":"IGAKit for Visualization","text":"<p>To download and install IGAKit, follow the instructions provided in the official GitHub repository.</p> <p>IGAKit is a lightweight Python toolkit that complements PetIGA by providing:</p> <ul> <li> <p>Geometry generation &amp; manipulation   \u2013 construct NURBS curves, surfaces, and volumes directly in Python.</p> </li> <li> <p>Visualisation helpers   \u2013 export control meshes, knot lines, and solution fields (VTK) for ParaView or VisIt.</p> </li> <li> <p>I/O utilities   \u2013 read/write <code>.iga</code> and IGES files, perform uniform refinements, and inspect knot vectors.</p> </li> </ul> <p>In this documentation we will use IGAKit mainly to visualise simulation output produced by PetIGA by converting <code>.dat</code> files to <code>.vtk</code> files, which can be visualized in paraview.  </p> <p>Installation tip: IGAKit is pure\u2011Python. Activate your conda environment on Bridges2 and run <pre><code>     pip install https://github.com/dalcinl/igakit/archive/refs/heads/master.zip\n</code></pre> or clone the repo and install manually: <pre><code>     git clone https://github.com/dalcinl/igakit\n</code></pre></p>"},{"location":"tutorial/","title":"Tutorial\u00a0I\u00a0\u00b7\u00a02\u2011D Heat\u2011Conduction Example","text":"<p>Objective \u2013 show an explicit PetIGA implementation for the transient heat\u2011diffusion equation and how to run it on your cluster.</p>"},{"location":"tutorial/#1-problem-description","title":"1\u00a0\u00b7\u00a0Problem description","text":"Item Value / comment Domain 2\u2011D square, side length\u00a0\\(L = 50\\). Boundary conditions Periodic on all four edges (model a repeating tile). Initial temperature Parabolic \u201chot spot\u201d centred at \\((L/2,L/2)\\): \\(T(\\mathbf x,0)=100\\Bigl[\\,1-\\bigl(\\tfrac{r}{0.5L\\sqrt{2}}\\bigr)^2\\Bigr]\\) where \\(r=\\|\\mathbf x-\\mathbf x_c\\|\\) and values below\u202f0 are clipped. Material property Thermal diffusivity\u00a0\\( \\alpha = \\dfrac{\\kappa}{\\rho c_p}=5.0 \\). Discretisation \\(\\Delta x = 0.5\\)\u00a0\u21d2\u00a0\\(100\\times100\\) elements; time step \\(\\Delta t = 5\\times10^{-4}\\). Heat source None (\\(q=0\\))."},{"location":"tutorial/#2-strong-form","title":"2\u00a0\u00b7\u00a0Strong form","text":"<p>Find \\(T(\\mathbf x,t)\\) such that</p> <p>\\[   \\rho\\,c_p\\;\\frac{\\partial T}{\\partial t} - \\kappa\\nabla^{2}T = 0   \\quad \\text{in}\\; \\Omega=[0,L]^2,\\; t&gt;0   \\]</p> <p>with periodic boundaries</p> <p>\\[   T(0,y,t)=T(L,y,t), \\qquad    T(x,0,t)=T(x,L,t),   \\]</p> <p>and initial condition</p> \\[ T(\\mathbf x,0)=T_\\text{init}(\\mathbf x). \\] <p>Because we prescribe periodicity, there is no Dirichlet (\\(\\Gamma_D\\)) or Neumann (\\(\\Gamma_N\\)) boundary\u2014the domain wraps onto itself.</p> <p>You can adjust \\(L,\\;\\alpha,\\;\\Delta x,\\;\\Delta t\\) via command\u2011line flags when running the example.</p>"},{"location":"tutorial/#3-get-the-demo-codes-from-heat2d","title":"3\u00a0\u00b7\u00a0Get the demo codes from  heat2d","text":"<p>This folder contains heat2D.c file, a makefile, a post processing file named post2.py and a batch script for running in the cluster</p>"},{"location":"tutorial/#4-quick-insights-into-the-code","title":"4 \u00b7\u00a0Quick insights into the code","text":""},{"location":"tutorial/#41-residual-assembly","title":"4.1 Residual assembly","text":"<p>The Residual() callback implements the weak form after multiplying the PDE by a test function, integrating by parts, and inserting the B\u2011spline shape functions. For heat conduction the residual per basis function \\(N_a\\) is  </p> \\[ R_a = -\\alpha \\, \\nabla N_a \\!\\cdot\\! \\nabla T , \\] <p>coded as:</p> <pre><code>PetscErrorCode Residual(IGAPoint pnt,\n                        PetscReal t,const PetscScalar *U,\n                        PetscScalar *Re,void *ctx)\n{\n\n  AppCtx *user = (AppCtx *)ctx;\n  PetscScalar sol; \n  PetscScalar grad[2];\n  IGAPointFormValue(pnt,U,&amp;sol);\n  IGAPointFormGrad (pnt,U,&amp;grad[0]);\n  PetscReal alpha = user-&gt;alpha;    \n\n\n  const PetscReal *N0,(*N1)[2];\n  IGAPointGetShapeFuns(pnt,0,(const PetscReal**)&amp;N0);\n  IGAPointGetShapeFuns(pnt,1,(const PetscReal**)&amp;N1);\n\n  PetscScalar (*Ra)[1] = (PetscScalar (*)[1])Re;\n  PetscInt a,nen = pnt-&gt;nen;\n  for (a=0; a&lt;nen; a++) { Ra[a][0] = -alpha*(N1[a][0]*grad[0] + N1[a][1]*grad[1]); }    \n\n  return 0;\n}\n</code></pre>"},{"location":"tutorial/#42-initial-condition","title":"4.2  Initial condition","text":"<p>Modify the temperature profile in FormInitialCondition(): <pre><code>    T = 100.0*(1-(dist/(0.5*user-&gt;Lx*1.414))*(dist/(0.5*user-&gt;Lx*1.414)));\n</code></pre></p>"},{"location":"tutorial/#43-output-monitor","title":"4.3  Output Monitor","text":"<p>OutputMonitor controls the frequency of writing the .dat file which contains the control variables. It also computes the lumped mass matrix vector which is substitued to <code>ts-&gt;vec_lump</code>.</p> <p>To change the frequency of printing the output files change the following in the OutputMonitor() function</p> <pre><code>  PetscInt fac = 2.0/user-&gt;dt;\n\n  if(step%fac==0)\n  { \n    // PRINTING OUTPUT FILES\n      sprintf(filename,\"./heat%d.dat\",step); \n      ierr = IGAWriteVec(iga,U,filename);CHKERRQ(ierr);\n  }\n</code></pre>"},{"location":"tutorial/#44-geometry-an-boundary-setup","title":"4.4  Geometry an boundary setup","text":"<pre><code>  IGA iga;\n  ierr = IGACreate(PETSC_COMM_WORLD,&amp;iga);CHKERRQ(ierr);\n  ierr = IGASetDim(iga,2);CHKERRQ(ierr);\n  ierr = IGASetDof(iga,1);CHKERRQ(ierr);\n\n  // setting boundary conditions\n  IGAAxis axis0;\n  ierr = IGAGetAxis(iga,0,&amp;axis0);CHKERRQ(ierr);\n  ierr = IGAAxisSetPeriodic(axis0,PETSC_TRUE);CHKERRQ(ierr);\n  ierr = IGAAxisSetDegree(axis0,p);CHKERRQ(ierr);\n  ierr = IGAAxisInitUniform(axis0,user.Nx,0.0,user.Lx,k);CHKERRQ(ierr);\n  IGAAxis axis1;\n  ierr = IGAGetAxis(iga,1,&amp;axis1);CHKERRQ(ierr);\n  ierr = IGAAxisCopy(axis0,axis1);CHKERRQ(ierr);\n  ierr = IGAAxisSetPeriodic(axis1,PETSC_TRUE);CHKERRQ(ierr);\n\n  ierr = IGASetFromOptions(iga);CHKERRQ(ierr);\n  ierr = IGASetUp(iga);CHKERRQ(ierr);\n</code></pre>"},{"location":"tutorial/#45-time-stepping-driver-explicit-euler","title":"4.5  Time-stepping driver (explicit Euler)","text":"<pre><code>  /* RHS only */\n  ierr = IGASetFormRHSFunction(iga, Residual, &amp;user);CHKERRQ(ierr);\n\n  /* lumped mass vector placeholder */\n  ierr = IGACreateVec(iga,&amp;user.lump);\n  ierr = VecSet(user.lump,1.0);\n\n  /* create explicit TS object */\n  TS ts;\n  ierr = IGACreateTS3(iga,&amp;ts);CHKERRQ(ierr);\n  ierr = TSSetProblemType(ts, TS_LINEAR);\n  ierr = TSSetMaxTime(ts,user.total_time);CHKERRQ(ierr);\n  ierr = TSSetTimeStep(ts,user.dt);CHKERRQ(ierr);\n  ierr = TSSetExactFinalTime(ts,TS_EXACTFINALTIME_MATCHSTEP);CHKERRQ(ierr);\n  ierr = TSSetType(ts,TSEULER);CHKERRQ(ierr);\n\n\n  /* output monitor */ \n  if (output)  {ierr = TSMonitorSet(ts,OutputMonitor,&amp;user,NULL);CHKERRQ(ierr);}\n  ierr = TSSetFromOptions(ts);CHKERRQ(ierr);\n\n  /* initial condition and solve */\n  Vec C;\n  ierr = TSGetSolution(ts,&amp;C);CHKERRQ(ierr);\n  ierr = FormInitialCondition(iga,C,&amp;user);CHKERRQ(ierr);\n  ierr = TSSolve(ts,C);CHKERRQ(ierr);\n</code></pre>"},{"location":"tutorial/#5-build-instructions","title":"5\u00a0\u00b7\u00a0Build instructions","text":"<p>Copy the files into the <code>demo/heat/</code> folder of your PetIGA clone (or any folder in <code>$PETIGA_DIR/demo</code>):</p> <pre><code>     cp -r heat2d  $PETIGA_DIR/demo/\n     cd $PETIGA_DIR/demo/heat2d\n</code></pre> <p>Compile:</p> <pre><code>```bash\n    make heat2D\n```\n</code></pre>"},{"location":"tutorial/#6-running-the-solver","title":"6 . Running the solver","text":"<p>Edit <code>run_heat2d.sh</code> to suit your cluster queue (Slurm, PBS, etc)</p> <p>Example run on 128 MPI ranks</p> <pre><code>    #!/bin/bash\n\n    #SBATCH -t 04:00:00\n    #SBATCH -n 128\n    #SBATCH -o \"%x.o%j\"\n    #SBATCH -e \"%x.e%j\"\n    #SBATCH --job-name=\"heat2D\"\n    #SBATCH --mem-per-cpu=1G\n    #SBATCH -p RM\n\n\n    # Run the main program\n    mpirun -np 128 ./heat2D -N 100 -dt 5e-4 -total_time 100.0 &gt; \"${SLURM_JOB_NAME}.o$id\"\n</code></pre>"},{"location":"tutorial/#7-results-visualisation","title":"7\u00a0\u00b7\u00a0Results\u00a0&amp; visualisation","text":"<p>Expected output files</p> <ul> <li><code>heat0.dat</code>, <code>heat4000.dat</code>, \u2026\u00a0(PetIGA solution binary snapshots)  </li> <li><code>lump.dat</code> file containing the lumped mass matrix vector</li> <li><code>igaphase.dat</code> file containing IGA metadata necessary for postprocessing</li> </ul> <p>Convert <code>.dat</code> files to VTK for ParaView <pre><code>from igakit.io import PetIGA,VTK\nfrom numpy import linspace\nimport glob\nfrom multiprocessing import Pool\nimport time\n\n# read in discretization info and potentially geometry\nnrb = PetIGA().read(\"igaphase.dat\")\n\n# enter the refinement factor\nrefinement = 2\n\n# write a function to sample the nrbs object\nuniform = lambda U: linspace(U[0], U[-1], int(len(U)*refinement))\n\n# function to print the fields into VTK files\ndef print_file(infile):\n    sol = PetIGA().read_vec(infile,nrb)\n    outfile = infile.split(\".\")[0] + \".vtk\"\n    VTK().write(outfile,       # output filename\n        nrb,                    # igakit NURBS object\n        fields=sol,             # sol is the numpy array to plot\n        scalars={'T':0})\n\nif __name__ == '__main__':\n    list_of_files = glob.glob(\"heat*.dat\")\n    t0 = time.time()\n    p = Pool(24)\n    p.map(print_file, list_of_files)\n    t1 = time.time()\n    print('Total post-processing time = %f secs'%(t1 - t0))\n</code></pre> Open the generated <code>heatXXXX.vtk</code> files in ParaView to visualise the temperature field.</p> <p></p> Figure\u00a01 \u2013     Numerical solution of the 2-D heat-conduction problem.     Left \u2192 initial condition (t = 0);\u00a0     centre \u2192 intermediate state (t = 10s);\u00a0     right \u2192 steady-state (t = 100s) where the field has relaxed to\u00a0T \u2248 66."},{"location":"tutorial2/","title":"Tutorial\u00a0II\u00a0\u00b7\u00a02\u2011D Cahn Hilliard Equation","text":"<p>In this example we focus on:</p> <ol> <li>How the Residual and Tangent functions differ between explicit and implicit time stepping  </li> <li>Minimal IGA setup common to both variants  </li> <li>Comparing results</li> </ol>"},{"location":"tutorial2/#1-problem-description","title":"1 \u00b7 Problem description","text":"<ul> <li>2-D periodic square \u03a9 = [0,1]\u00b2  </li> <li>Order-parameter \\(c(\\mathbf x,t)\\) representing concentration (0 \u2264 c \u2264 1)  </li> <li>Temperature ratio \u03b8 = 1.5, interface-parameter \u03b1 = 3000  </li> <li>Mobility \\(M(c)=c(1-c)\\) </li> <li>Random initial condition with mean \\( \\bar c = 0.63\\)</li> </ul>"},{"location":"tutorial2/#2-strong-form","title":"2 \u00b7 Strong form","text":"<p>The Cahn\u2013Hilliard system couples a conserved order parameter \\(c\\) with its chemical potential \\(\\mu\\):</p> \\[ \\begin{aligned} \\frac{\\partial c}{\\partial t} &amp;= \\nabla\\!\\cdot\\!\\bigl(M(c)\\,\\nabla\\mu \\bigr),  \\\\[4pt] \\mu &amp;= \\frac{\\partial\\Psi}{\\partial c} \\;-\\; \\alpha\\,\\theta\\,\\nabla^{2}c, \\end{aligned} \\] <p>where  </p> \\[ \\Psi(c) = \\tfrac12 \\theta\\,\\bigl[c\\ln c + (1-c)\\ln(1-c)\\bigr] + \\theta\\,c(1-c) \\] <p>yields  </p> \\[ \\frac{\\partial\\Psi}{\\partial c} \\;=\\; \\tfrac12\\theta \\ln\\!\\left(\\frac{c}{1-c}\\right)+\\theta\\,(1-2c). \\] <p>Boundary conditions are periodic; source term \\(q=0\\).</p>"},{"location":"tutorial2/#3-code-structure-overview","title":"3 \u00b7 Code structure overview","text":"<p>Download the codes from cahnHiliard</p> File Purpose <code>ch2d_explicit.c</code> explicit Euler (<code>TSEULER</code>) \u2013 Residual only <code>ch2d_implicit.c</code> implicit (<code>TSALPHA</code>, or <code>TSTheta</code>) \u2013 Residual + Tangent <code>run.sh</code> batch script template <p>We show only the parts that differ between the two builds\u2014everything else (domain, axis settings, initial condition, monitors) is shared.</p>"},{"location":"tutorial2/#31-explicit-variant-residual-only","title":"3.1 Explicit variant \u2013 Residual only","text":"<pre><code>/* ---------------- Residual for explicit solver ---------------- */\nPetscErrorCode Residual(IGAPoint p,\n                        PetscReal t,const PetscScalar *U,\n                        PetscScalar *R,void *ctx)\n{\n  AppCtx *user = (AppCtx *)ctx;\n\n  /* c,  \u2207c,  \u2207\u00b2c  */\n  PetscScalar  c, gradc[2], del2c;\n  IGAPointFormValue (p,U,&amp;c);\n  IGAPointFormGrad  (p,U,&amp;gradc[0]);\n  IGAPointFormDel2  (p,U,&amp;del2c);\n\n  /* mobility and d(mu)/dc */\n  PetscReal M,dM;\n  Mobility(user,c,&amp;M,&amp;dM,NULL);\n\n  PetscReal dmu;\n  ChemicalPotential(user,c,NULL,&amp;dmu,NULL);\n\n  /* weak form */\n  const PetscReal (*N0)    = (typeof(N0)) p-&gt;shape[0];\n  const PetscReal (*N1)[2] = (typeof(N1)) p-&gt;shape[1];\n  const PetscReal (*N2)[2][2] = (typeof(N2)) p-&gt;shape[2];\n\n  PetscInt a, nen = p-&gt;nen;\n  for (a=0; a&lt;nen; a++) {\n    PetscReal Na_x  = N1[a][0];\n    PetscReal Na_y  = N1[a][1];\n    PetscReal Na_xx = N2[a][0][0];\n    PetscReal Na_yy = N2[a][1][1];\n\n    PetscScalar Ra  = 0.0;\n    PetscScalar t1  = M*dmu + dM*del2c;\n\n    Ra -= (Na_x*gradc[0] + Na_y*gradc[1]) * t1;     /* convective part   */\n    Ra -= (Na_xx+Na_yy) * M * del2c;                /* diffusion part    */\n    R[a] = Ra;\n  }\n  return 0;\n}\n</code></pre> <p>No Jacobian is registered; the driver simply calls</p> <pre><code>    IGASetFormRHSFunction(iga, Residual, &amp;user);\n    IGACreateTS3(iga,&amp;ts);      /* attaches RHS only          */\n    TSSetType(ts, TSEULER);     /* forward Euler time stepper */\n</code></pre>"},{"location":"tutorial2/#32-implicit-variant-residual-and-tangent","title":"3.2 Implicit variant \u2013 Residual and Tangent","text":"<p>The only difference in the residual is the function call and addition of time derivative term in the weak form</p> <pre><code>PetscErrorCode Residual(IGAPoint p,\n                        PetscReal shift,const PetscScalar *V,\n                        PetscReal t,const PetscScalar *U,\n                        PetscScalar *R,void *ctx)\n</code></pre> <pre><code>    for (a=0; a&lt;nen; a++) {\n    PetscReal Na    = N0[a];\n    PetscReal Na_x  = N1[a][0];\n    PetscReal Na_y  = N1[a][1];\n    PetscReal Na_xx = N2[a][0][0];\n    PetscReal Na_yy = N2[a][1][1];\n    /* ----- */\n    PetscScalar Ra  = 0;\n    // Na * c_t\n    Ra += Na * c_t;\n    // grad(Na) . ((M*dmu + dM*del2(c))) grad(C)\n    Ra += (Na_x * c_x + Na_y * c_y) * t1;\n    // del2(Na) * M * del2(c)\n    Ra += (Na_xx+Na_yy) * M * del2_c;\n    /* ----- */\n    R[a] = Ra;\n  }\n</code></pre> <p>Add the Jacobian kernel:</p> <pre><code>PetscErrorCode Tangent(IGAPoint p,\n                       PetscReal shift,const PetscScalar *V,\n                       PetscReal t,const PetscScalar *U,\n                       PetscScalar *K,void *ctx)\n{\n   /* identical preamble to Residual(): compute c, \u2207c, mobility, etc. */\n  /* ... */\n\n\n  const PetscReal (*N0)       = (typeof(N0)) p-&gt;shape[0];\n  const PetscReal (*N1)[2]    = (typeof(N1)) p-&gt;shape[1];\n  const PetscReal (*N2)[2][2] = (typeof(N2)) p-&gt;shape[2];\n\n  PetscInt a,b;\n  for (a=0; a&lt;nen; a++) {\n    PetscReal Na    = N0[a];\n    PetscReal Na_x  = N1[a][0];\n    PetscReal Na_y  = N1[a][1];\n    PetscReal Na_xx = N2[a][0][0];\n    PetscReal Na_yy = N2[a][1][1];\n    PetscReal del2_Na = Na_xx+Na_yy;\n    for (b=0; b&lt;nen; b++) {\n      PetscReal Nb    = N0[b];\n      PetscReal Nb_x  = N1[b][0];\n      PetscReal Nb_y  = N1[b][1];\n      PetscReal Nb_xx = N2[b][0][0];\n      PetscReal Nb_yy = N2[b][1][1];\n      PetscReal del2_Nb = Nb_xx+Nb_yy;\n      /* ----- */\n      PetscScalar Kab = 0;\n      // shift*Na*Nb\n      Kab += shift*Na*Nb;\n      // grad(Na) . (M*dmu+dM*del2(c)) grad(Nb)\n      Kab += (Na_x * Nb_x + Na_y * Nb_y) * t1;\n      // grad(Na) . ((dM*dmu+M*d2mu+d2M*del2(c))*Nb + dM*del2(Nb)) grad(C)\n      PetscScalar t3 = t2*Nb + dM*del2_Nb;\n      Kab += (Na_x * c_x + Na_y * c_y) * t3;\n      // del2(Na) * ((dM*del2(c)*Nb + M*del2(Nb))\n      Kab += del2_Na * (dM*del2_c*Nb + M*del2_Nb);\n      /* ----- */\n      K[a*nen+b] = Kab;\n    }\n  }\n  return 0;\n}\n</code></pre> <p>and register:</p> <pre><code>    IGASetFormRHSFunction(iga, Residual, &amp;user);\n    IGASetFormIJacobian (iga, Tangent,  &amp;user);\n\n    TSSetType(ts, TSALPHA);          /* implicit, unconditionally stable */\n    TSAlphaSetRadius(ts, 0.5);       /* parameters as desired            */\n</code></pre>"},{"location":"tutorial2/#33-common-iga-setup-shared","title":"3.3 Common IGA setup (shared)","text":"<pre><code>    IGACreate(PETSC_COMM_WORLD,&amp;iga);\n    IGASetDim(iga,2);       /* 2-D */\n    IGASetDof(iga,1);       /* scalar field c */\n    IGAAxisSetPeriodic(axis0,PETSC_TRUE);\n    IGAAxisInitUniform(axis0, N, 0.0, 1.0, k);\n    IGAAxisCopy(axis0, axis1);           /* copy settings to Y */\n    IGASetUp(iga);\n</code></pre>"},{"location":"tutorial2/#4-running-and-compiling-the-codes","title":"4 \u00b7 Running and compiling the codes","text":"<ul> <li> <p>Compilation \u2013 same <code>make</code> targets: <code>make ch2d_explicit</code>, <code>make ch2d_implicit</code></p> </li> <li> <p>Run scripts \u2013 <code>sbatch run.sh</code></p> </li> <li> <p>Metrics \u2013 compare free-energy decay, mass conservation, and wall-clock time.</p> </li> <li> <p>Visualisation \u2013 convert <code>ch2dXXXX.dat</code> to VTK exactly as in Tutorial I, <code>post2.py</code> also provided in the download folder</p> </li> </ul>"},{"location":"tutorial2/#5-results-and-visualization","title":"5 \u00b7 Results and visualization","text":""},{"location":"tutorial2/#51-what-to-expect-physically","title":"5.1 What to expect physically","text":"Observable Explicit / implicit outcome Total mass \\( \\displaystyle \\int_\\Omega c \\,d\\Omega \\) Conserved to machine precision (both schemes). Free energy \\( \\displaystyle \\mathcal F(t)=\\int_\\Omega \\Psi(c)+\\tfrac12\\alpha\\theta\\nabla c\\cdot\\nabla c\\,d\\Omega \\) Monotonically decreases \u2192 plateaus when the interface reaches equilibrium. Spinodal decomposition Initial random field separates into two nearly-pure phases (\\(c\\!\\approx\\!0\\) and \\(c\\!\\approx\\!1\\)) connected by thin interfaces.  Droplets coarsen via Ostwald ripening until one domain percolates. <p>Open ch2d*.vtk in ParaView; colour by scalar c. You should see:</p> <ol> <li> <p>Early time \u2013 fine \u201csalt-and-pepper\u201d mixture of red/yellow.</p> </li> <li> <p>Intermediate \u2013 domains elongate and coarsen.</p> </li> <li> <p>Late time \u2013 two bulk regions separated by a smooth interface. \u200b</p> </li> </ol> <p></p> Figure\u00a02 \u2013 2-D Cahn\u2013Hilliard phase separation: implicit\u00a0vs explicit. Top row \u2013 implicit scheme snapshots at increasing times. Bottom row \u2013 explicit scheme at the same times.     Both solvers conserve mass and lower the Ginzburg\u2013Landau free energy; interfaces sharpen and coarsen until two bulk phases remain."},{"location":"tutorial2/#6-references","title":"6 \u00b7 References","text":"<ol> <li>G\u00f3mez, H., Calo, V. M., Bazilevs, Y., &amp; Hughes, T. J. (2008). Isogeometric analysis of the Cahn\u2013Hilliard phase-field model. Computer methods in applied mechanics and engineering, 197(49-50), 4333-4352.</li> </ol>"}]}